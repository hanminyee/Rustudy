//슬라이스 타입

/*
슬라이스 타입은 소유권을 갖지 않는 타입이다(참조랑 비슷).
슬라이스를 이용하면 컬렉션 전체가 아니라 컬렉션 안의 연속된 요소들을 참조할 수 있다.
*/
fn first_word(s: String) -> usize{
    let bytes = a.as_bytes();

    for(i, &item) in bytes.iter().enumerate(){
        if item == b' '{
            return i;
        }
    }
    s.len()
}
/*
위 함수를 보자. 위 함수는 전달받은 문자열에서 첫 번째 단어만 리턴하는 함수이다.
우선, String타입에 저장된 문자열 내의 각 문자들을 살펴보면서 해당 문자가 공백인지 아닌지를 확인해야한다.
그래서 as_bytes 메소드를 이용해 String타입을 바이트 배열로 변환시킨다.
그 다음에는 iter메소드를 호출해 바이트 배열의 반복자를 생성한다.(반복자에 대해서는 13장에서 살펴보자)
iter 메소드는 컬렉션의 원소들을 차례로 리턴하고, enumerate 메소드는 iter메소드의 결과를 감싸서 각 원소를 튜플 형태로 리턴한다.
튜플의 첫번째 요소는 인덱스이고, 두번째 요소는 해당 요소에 대한 참조이다. 이 메소드를 이용하면 인덱스를 직접 계산할 필요는 없음

enumerate메소드는 튜플을 리턴하므로 다른 러스트 코드에서와 마찬가지로 튜플을 해제하는 패턴을 사용하면 된다.
따라서 루프 안에서 인덱스는 변수 i에, 바이트 요소를 &item에 할당한다. 이때 iter().enumerate()메소드가 리턴하는 요소에 대한 참조를 얻어오는거라 & 사용한거임

for루프 안에서는 바이트 리터럴 분법을 이용해 공백을 표현하는 바이트를 탐색함.
if item == b' ' 라는 말은 "만약에 바이트 리터럴이 공백이면" 이라는 말임
공백이면? 해당 위치(i)를 리턴함
근데 공백이 없으면? s.len()을 통해 문자열의 전체 길이를 리턴함.

근데 문제는 이 함수가 usize타입을 리턴하는데, 이 값은 &String타입에 대해서만 의미가 있다.
근데 이 함수의 리턴값은 String타입과는 다른거라 나중에도 이 값이 유효할 것이라는 보장이 없다.
*/
fn main(){
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear();
}
/*
근데 이 코드는 문제없이 컴파일 되긴 한다.
s.clear()은 문자열을 비워 빈 문자열을 만드는건데, 이 메소드를 호출한 후에도 word변수는 여전히 유효하다.
그치만, word변수는 더이상 문자열 변수 s의 상태를 반영하지 못하므로 여전히 5 라는 값(hello읽어서 길이 리턴받은 값)을 저장하고있다.
그래서 이 값을 이용해서 문자열 변수 s에서 첫번째 단어를 추출하려고 하면, 변수 s의 내용이 이미 바뀌어서 버그가 나타나벌임;;
그러면 word변수를 s의 변화에 따라 자동수정 해주면 되는거 아닌가요?
그렇게하면 너무 비효율적이고 버그 많이남. 게다가 second_word라는 함수를 작성한다고 하면 인덱스를 관리하기가 더 난감해짐. 왜냐면 인덱스를 fn second_word(s: &String) -> (usize, usize) 뭐 이런식으로 해야함

이런거를 관리하기 위해 러스트는 "문자열 슬라이스"라는 기능을 제공함
*/
