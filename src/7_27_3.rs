/*
데이터 타입의 종류

우선, 러스트에서 모든 값은 어떤 타입의 데이터임.
각각의 데이터는 "스칼라 타입" 과 "컴파운드 타입"으로 나뉘어져 있는데, 이걸 알아보자.
러스트는 정적 타입 언어다. 즉, 컴파일 시점에 모든 변수의 타입이 결정되어야 한다는 말임.
컴파일러는 타입 추론을 통해 변수에 할당된 값이나 변수의 사용을 보고 실제 타입을 예측함
우리가 이전에 했던 것 처럼 문자열을 숫자 타입으로 변경할 때, "타입 이노테이션"을 이용해 타입을 명시해 주어야함
ex) let guess: u32 = "42".parse().expect("숫자가 아닙니다!");
*/

fn main() {
    //정수
    let integer: i8; //8비트 짜리 정수
    let integer: i16; //16비트짜리 정수
    let integer: i32; //32비트짜리 정수
    let integer: i64; //64비트짜리 정수
    let integer: isize; //arch비트짜리 정수(현재 프로그램이 실행 중인 컴퓨터의 종류에 따라 정해짐 그냥 윈도우 32비트면 32비트, 64비트면 64비트 이렇게)
    let integer: u8; //부호없는 8비트.. 이렇게 쭉 이어져감. 부호없는건 위에꺼 i를 u로 바꾸면 됨

    //부동소수점 타입
    let x: f64 = 2.0; //64비트짜리. 기본적으로 러스트는 64비트 짜리를 제공함
    let y: f32 = 3.0; //32비트짜리 필요하면 이렇게 씀

    //사칙연산 이런거들 let 할 때 쓸 수 있다 이정도(그냥 당연한거임)
    let sum = 5 + 10; 
    let difference = 95.5 - 4.3;
    let product = 4 * 30;
    let quotient = 56.7 / 32.2;
    let remainder = 43 % 5;

    //불리언 타입
    let t = true; //타입 추론 때문에 이렇게 해도 불리안으로 알아먹음
    let f: bool = false; //명확히 표시해주려면 :bool 붙이면 됨

    //문자 타입
    let c = 'z'; //한글자씩 가능
    let z = 'r'; //작은 따옴표 ' 로 표현
    let happy = '🙂'; //러스트는 4byte 크기의 유니코드 스칼라값으로 char타입을 저장해서 아스키보다 더 많은 문자 표현 가능. 심지어 한국어, 중국어, 일본어, 이모지 다 가능
    println!("happy = {}", happy);


    /********************************************************************/
    /***************************컴파운드 타입*****************************/
    /********************************************************************/
    //컴파운드 타입은 하나의 타입으로 여러 개의 값을 그룹화한 타입임. 기본적으로 "튜플"과 "배열" 두가지를 제공함

    /*
    튜플 타입
    서로 다른 타입의 여러 값을 하나의 컴파운드 타입으로 그룹화하기에 적합한 타입.
    고정된 길이를 가지고 한번 정의하면 그 크기를 키우거나 줄일 수 없음
    튜플 생성시에는 괄호 안에 값의 목록을 쉼표로 구분해서 표기하면 됨.
    각 요소는 타입을 가지고 타입이 같을 필요는 없음.
    아래처럼 타입 애노테이션을 할 수도 있지만 안해도 알아서 알아먹더라
     */
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("y의 값: {}", y); //이런식으로 접근이 가능함. 그냥 바로 대입때려도 알아먹음
    let a = tup.0;
    let b = tup.1;
    let c = tup.2;
    println!("a의 값 : {}\nb의 값 : {}\nc의 값: {}", a,b,c); //이렇게 .n 으로 인덱스 접근이 가능함. 당연하게 인덱스는 0부터 시작.

    /*
    배열 타입
    튜플이랑 다르게 배열은 반드시 각 요소의 타입이 같아야함.
    러스트의 배열은 길이가 고정되어있음.또한 배열에 저장할 값은 대괄호 안에 쉼표로 구분
    배열은 기본적으로 스택 메모리에 할당됨. 벡터만큼 유연하지는 않은데 기본적으로 둘 중에 뭘 써야할지 모르겠다 싶으면 배열이 나음
     */
    let a = [1, 2, 3, 4, 5];
    let months = ["January", "February", "...", "December"];
    let a: [i32; 5] = [1, 2, 3, 4, 5]; //이런식으로 배열의 타입과 길이를 미리 정하고 초기화 할 수 있음.
    let a = [3; 5]; //이렇게 하면 3이 5개 들어있는 배열이 만들어짐
    let b = a[0]; //이렇게 인덱싱 접근 가능
    /* 주의할 점
    유효하지 않은 배열 요소에 접근하면(예를들어 길이가 5인데 10번째 인덱스라던가) 러스트는 컴파일 시점에선 에러가 안나는데, 실행하면 런타임 에러가 남
    러스트는 인덱스를 이용해서 배열의 요소를 읽을 때, 지정된 인덱스가 배열의 전체 길이보다 작은 값인지를 검사함.
    만약 인덱스가 배열의 길이보다 크다면 러스트는 앞서 에러메시지에서 보듯이 패닉이 발생함
    근데 우리 다른 언어들 생각해보면 런타임 에러가 아니라 이상한 주솟값 읽어오는 새끼들 개많음
    러스트는 이러한 점을 방지하기 위해 아예 패닉을 일으킴. 즉, 엉뚱한 메모리에 대한 접근을 허용하지 않고 바로 중단시켜서 보안에 좋음.
     */

}
