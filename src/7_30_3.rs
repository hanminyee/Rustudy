fn main(){
    let reference_to_nothing = dangle();
}
fn dangle() -> &String{
    let s = String::from("hello");

    &s
}
/*
위 코드는 안돌아감.
왜냐면 "죽은 참조"라는 건데, 죽은 포인터 생각하면 됨.
죽은 포인터란?
이미 해제되어 다른 정보를 저장하도록 변경된 메모리를 계속해서 참조하는 포인터를 이야기함.
근데 러스트는 이런 죽은 참조가 발생하지 않도록 컴파일러가 보장해줌.
즉, 어떤 데이터에 대한 참조를 생성하면 컴파일러가 해당 데이터에 대한 참조를 실행하기 전에, 데이터가 범위를 벗어나지 않았는지 확ㅇ니함.

위 코드의 에러는 "수명"에 대해 언급하는데, 이건 10장에 나옴.
다른 말도 중요한데 "이 함수의 리턴 타입은 대여한 값을 리턴하고자 하지만 실제로 대여해 줄 값이 존재하지 않습니다." 라고 이야기함.

dangle()함수를 좀 더 살펴보자면
우선 변수 s가 dangle함수 "내부"에서 생성되었음. 그래서 dangle함수의 실행이 종료되는 시점에 변수 s의 메모리가 해제됨.
하지만 이 함수는 해제된 메모리에 대한 참조를 리턴하려고 함. 그래서 ㅈ버그 남.
이걸 해결하려면 dangle 함수를
fn dangle() -> &String{
    let s = String::from("hello");

    s
}
이런식으로 String타입을 직접 리턴하도록 만들면 돌아감.
*/

/*
참조에 대한 큰 규칙은 2가지가 있음.
1. 어느 한 시점에 코드는 하나의 가변 참조 또는 여러 개의 불변 참조를 생성할 수 있지만, 둘 모두를 생성할 수는 없다.
2. 참조는 항상 유효해야 한다.
위 2가지만 지키면 참조를 잘 할 수 있음.
내일은 다른 형태의 참조인 "슬라이스(slices)"에 대해 알아보는 시간을 가져보자.
*/
