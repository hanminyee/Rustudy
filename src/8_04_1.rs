/*
Option 열거자라는게 있음.
얘는 뭐냐면 표준 라이브러리가 제공하는 친구임
왜냐면 어떤 값이 존재하거나 존재하지 않는, 아주 범용적인 시나리오에 적합하도록 디자인 되었음.
타입 시스템이 이런 타입을 제공한다는 것은 코드가 모든 경우의 수를 처리하고 있는지를 컴파일러가 확인할 수 있다는 것을 의미함.
그래서 버그방지에 쓰임. 어캐쓰이는지 알아보자.

우선, 프로그래밍 언어들은 대부분 NULL값을 가지고있음. 근데 러스트는 없음.
널값은 아무런 값을 가지지 않는 경우를 의미하는데, 널값을 지원하는 언어에서 변수는 항상 널이거나 널이 아니거나 두개의 상태 중 하나임.
근데 이새끼가 문제가 있는데 널값을 널이 아닌 값처럼 사용하려고 하면 에러가 발생함.
그래서 러스트는 그걸 해결하려고 어떤 값의 존재 여부를 표현하는 열거자를 정의하고있음. 이 열거자가 바로 Option<T>이며 표준 라이브러리에 다음과 같이 정의됨

enum Option<T>{
    Some(T),
    None,
}

Option<T> 열거자는 존나 유용함. 심지어 프렐류드에 포함되어 있음.  <T> <-- 얘는 제너릭인데 나중에 설명해줌
그래서 이 열거자는 명시적 범위가 필요없음 즉, Option:: 접두어 없이도 Some 이나 None값을 직접 사용할 수 있음.
아래 코드를 보자
*/

fn main(){
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None;
}
/*
위를 보면 Some()을 사용하는 경우라면 특정한 값이 존재하고, 그 값이 Some값 내에 저장되어 있음을 알림
근데 None은 널과같은 의미가 있음. 즉, 현재 유효한 값이 없다는 것을 의미함.
널을 사용하는 것 보다 Option<T> 를 사용하는 것은 장점이 있는데, 바로 Option<T> 와 T는 다른 타입이기 떄문에
컴파일러는 유요한 값이 명확히 존재할 때는 Option<T>값을 사용하는 것을 허락하지 않는다. 예를들어 아래의 코드는 작동하지 않는다.

let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;

왜냐면 옵션으로 부여한 값과 x의 타입은 다르기 떄문이다.

그러면, Option<T>타입을 사용하는 경우 Some값으로부터 T타입의 값을 어떻게 알아낼 수 있을까?
그래서 다양한 메소드를 제공하는데, 이건 러스트 공식문서에서 확인하셈.
*/
