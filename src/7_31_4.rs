//문자열 슬라이스 파라미터
/*
이전에 만들었던 first_word함수를 더 개선할 수 있는데,
리터럴이나 String타입의 값으로부터 슬라이스를 생성할 수 있다는 것은, String타입과 &str타입 값에 대해 모두 적용할 수 있다는 것이다.
아래의 형식으로 함수를 사용해보자
문자열 슬라이스는 함수에 직접 전달할 수 있다. 그래서 String타입을 다루는 경우라면 전체 문자열의 슬라이스를 전달하면 된다.
String타입에 대한 참조 대신에 문자열 슬라이스를 함수의 파라미터로 사용하면 같은 기능을 유히자면서도 더 보편적이고 유용하게 사용이 가능함.
*/
fn first_word(s: &str) -> &str{
    let bytes = s.as_bytes();

    for(i, &item) in bytes.iter().enumerate(){
        if item == b' '{
            return &s[0..i];
        }
    }
    &s[..]
}
fn main(){
    let my_string = String::from("hello world");

    let word = first_word(&my_string[..]); //first_word 함수에 String타입으로부터 생성한 문자열 슬라이스를 넘긴다

    let my_string_literal = "hello world"; //한 지점을 가리키는 슬라이스 타입인 &str타입

    let word = first_word(&my_string_literal[..]); //first_word 함수에 문자열 리터럴의 슬라이스를 넘긴다

    let word = first_word(my_string_literal); //문자열 리터럴은 이미 문자열 슬라이스라서 아래의 코드는 슬라이스 문법 없이도 정상적으로 작동함.

    let word = first_word(&my_string); //얘도 작동 하기는함
}

//여러종류의 슬라이스
fn slices(){
    let a = [1,2,3,4,5];

    let slice = &a[1..3];

    /*
    이런식으로 사용할 수도 있기는 함. 근데 슬라이스 자체가 문자열에 특화된거임.
    문자열의 일부만 참조할 때와 마찬가지로 이 배열의 일부만 참조하려면 위에 처럼 쓰면 됨.
    이 슬라이스는 &[i32]타입임. 문자열 슬라이스와 마찬가지고 첫 번째 요소와 길이에 대한 참조를 지정하는 방식으로 작동함.
    이런 형태의 슬라이스는 모든 종류의 컬렉션에 대해 활용할 수 있음.
    컬렉션은 8장 벡터에서 다룸.
     */
}

/*
소유권, 대여, 슬라이스는 러스트 프로그램의 컴파일 시점에 메모리 안정성을 확보하기 위한 개념들임.
러스트는 다른 시스템 프로그래밍 언어들과 같은 방법으로 메모리 사용에 대한 완전한 통제권을 개발자에게 제공하지만, 데이터의 소유자가 범위를 벗어날 때 자동으로 해당 데이터의
소유권을 해제함으로써 메모리의 안전한 사용이나 디버깅을 위한 추가 코드를 전혀 작성할 필요가 없음.

소유권은 러스트의 동작에 광범위하게 영향을 미치니까 이 책의 남은 부분을 통해 계속해서 다룰 예정임. 이제 5장으로 드가자!!
*/
