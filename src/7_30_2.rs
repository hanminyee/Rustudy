fn main(){
    let mut s = String::from("hello");

    change(&mut s);
}
fn change(some_string: &mut String){
    some_string.push_str(", world!");
}

/*
가변참조는 mut키워드를 통해 이루어진다.
변수에 mut키워드를 추가하고, 함수에 넘겨줄 때 &mut <변수명> 과 같은 형식으로 넘겨주면 함수 내부에서 값을 변경하는 것이 가능해진다.

근데 가변참조에도 제약이 있다.
아래 코드를 살펴보자
*/
fn wrong_code(){
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;
    println!("{},{}", r1, r2);
}
/*
위와 같은 방법은 컴파일 될 수 없다.
왜냐면 특정 범위 내의 특정 데이터에 대한 가변 참조는 오직 한 개만 존재할 수 있기 때문이다.

그러면, 이걸 왜 이딴식으로 만들어논거임? 개빡세게?
그 이유는 단 하나, 데이터 경합을 막기 위해서다.
데이터 경합은
1. 둘 혹은 그 이상의 포인터가 동시에 같은 데이터를 읽거나 쓰기 위해 접근할 때
2. 최소한 하나의 포인터가 데이터를 쓰기 위해 사용될 때
3. 데이터에 대한 접근을 동기화 할 수 있는 메커니즘이 없을때
위 3개의 경우에 발생하는데, 이러한 데이터 경합은 예측할 수 없는 결과를 유발하고, 런타임 시에 원인을 파악하고 수정하기가 매우 힘들다.
러스트는 이러한 데이터 경합이 발생하는 코드의 컴파일 자체를 허용하지 않음으로 이 문제를 예방한다.

그리고 여러개의 가변참조를 활용할 수 있는 방법이 존재하는데 간단하다. 중괄호를 추가하면 된다.
*/
fn run(){
    let mut s = String:: from("hello");
    {
        let r1 = &mut s;
    }//r1의 참조가 범위를 벗어나서 사라짐
    let r2 = &mut s;
}
/*
이렇게 하면 가변참조를 여러개 사용할 수 있음. 왜냐면 범위를 벗어난 참조는 사라지기 때문
*/
fn run2(){
    let mut s = String:: from("hello");

    let r1 = &s;
    let r2 = &s;
    let r3 = &mut s;
}
/*
이건 안됨.
왜냐면 불변참조를 이미 사용중일 때는 가변참조를 생성할 수 없음.
가변참조는 다른 참조가 없고, 자기 혼자만 존재할 때 사용할 수 있는 것임.
불변참조는 어차피 안변하니까 데이터 경합이 생길 수 없음. 그래서 여러개 만들어도 노상관.
*/
