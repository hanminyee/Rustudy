fn main() {
    let x = 5;

    let x = x+1;

    let x = x*2;

    println!("x의 값: {}", x);

}
/*
러스트는 변수 가리기 라는 기능을 제공한다.
이미 선언한 변수의 이름과 똑같은 이름의 변수를 선언할 수 있는데,
이때 이전에 전언한 변수는 새로 선언한 변수 때문에 가려진다(덮어쓰기 생각하면 편함).

이걸 사람들은 첫 번째 변수가 두 번째 변수에 의해 가려졌다(shadowed)라고 표현함.

위 프로그램은 우선 x에 5를 할당하고, 다시 let x = x+1; 을 이용해 x에 6을 할당한다.
3번째를 통해 x에 12를 할당하고 x값을 출력하는 프로그램이다.

그런데, 특이한 점이 있다.
분명 변수가 기본적으로 불변이라고 하지 않았던가? 근데 이런 방식으로 쓰면 그냥 변수 가변적인거 아니냐?
ㄹㅇㅋㅋ 맞음 근데 이건 mut 키워드 쓰는 방법이랑은 다름.
let 키워드를 이용해 변수를 새로 선언하지 않고 값만 할당하면 컴파일 에러가 발생함.
이건 소유권이랑 관련이 있는데 이게 러스트의 가장 큰 특징 중 하나임. 근데 이건 나중에 설명할라나봄 여기선 언급이 없네 ㅇㅇ

그리고 mut랑 다른점은 mut 를 쓰면 타입은 변경이 불가능한데 이런식으로 새로 선언하는건 타입 변경이 가능함
예를들어
let spaces = "     ";
let spaces = spacex.len();
하면 첫번째 스페이스는 String이지만, 두번째 스페이스는 정수값으로 들어감

근데 mut를 사용하면
let mut spaces = "     ";
spaces = spaces.len();
이렇게 사용하게 되는데 이건 ㅈ버그뜸 왜Why?
이건 새로운 선언을 하는게 아니기때문에 데이터타입이 계속 String이기 때문
*/
