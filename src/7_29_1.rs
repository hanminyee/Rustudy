/*
프로그램은 실행 중인 동안에는 어떤 방법으로든 컴퓨터의 메모리를 관리해야하는데, 어떤 언어는 "가비지 콜렉터"라는 것을 사용하거나 어떤 언어는 프로그래머가 직접 메모리를 할당하고 지움
근데 러스드는 이 두개 다 아님. 메모리는 "소유권"이라는 개념에 의해 관리됨.

소유권이란 뭐냐?
이걸 이해하려면 스택 메모리랑 힙 메모리를 이해해야 하는데 난 했음 ㅇㅇ
그냥 소유권의 개념을 이용해서 메모리에 접근할 때 시간이 상대적으로 오래 걸리는 힙 메모리를 잘 관리하기 위해 존재하는거임

소유권은 규칙이 있음
1. 러스트가 다루는 각각의 값은 "소유자(owner)"라고 부르는 변수를 가지고 있다.
2. 특정 시점에 값의 소유자는 단 하나뿐이다.
3. 소유자의 범위를 벗어나면 그 값은 제거된다.
*/

fn main() {
    {                   // 변수 s를 아직 선언하지 않았으므로 변수가 유효하지 않음
        let s = "hello";// 변수 s는 이 지점부터 유효함
                        // 변수 s로 필요한 동작 수행...
    }                   // 여기서 범위를 벗어나므로 변수 s는 이제 유효하지 않음.

    
    let s = String::from("hello");
    /*
    러스트에서 문자열과 String타입은 다름. 문자열은 스텍 메모리에 들어가지만 String은 힙에 들어감.
    둘의 다른점은 문자열 리터럴은 불변이지만 String::from()으로 생성한거는 변경 가능함.
    from함수는 간단하게 앞에 붙은 타입의 인스턴스를 생성하는 메소드임.
    :: 은 from 함수를 String 타입의 이름 공간으로 제한해서 string_from같은 이름 대신에 더 명료한 이름을 사용하기 위해서 쓰임.
     */
    let mut s = String::from("hello");

    s.push_str(", world!"); //push_str()은 String 인스턴스에 리터럴을 결합함

    println!("{}", s);
    /*
    String타입과 문자열 리터럴은 어떻게 다른걸까?
    이 차이점은 두 타입이 메모리를 다루는 방법에 있다.

    우선, 문자열 리터럴은 컴파일 시점에 문자열의 내용을 이미 알고 있으므로 텍스트를 최종 실행할 수 있는 형태로 직접 하드코딩 할 수 있다.
    그래서 빠르고 효율적임. 하지만 이 빠르고 효율적이라는 장점 자체가 얘가 불변이라서 가능한거 ㅇㅇ
    
    그런데 String타입은 길이를 조정할 수 있음.
    그래서 컴파일 시점에 알 수 없는 내용을 저장하기 위해 힙 메모리에 일정 부분의 메모리를 할당해야함
    그래서 2가지를 꼭 거치는데
    1. 해당 메모리는 꼭 런타임에 운영체제에 요청해야함
    2. String타입이 사용완료되면 메모리를 운영체제에 다시 돌려줘야함.
    1번째는 개발자가 하는거고, 2번째가 문제인데 다른 언어들은 2번째 절차를 가비지콜렉터가 해줌.
    근데 러스트는 변수가 범위(scope)를 벗어나면 자동으로 해제함. 즉 범위를 벗어난 변수는 다시는 사용이 불가함.
     */
    {
        let s = String::from("hello"); //변수가 유효해짐
                                        //변수로 동작 수행
    }                                   //이제 범위를 벗어나서 변수 s는 유효하지 않음
    /*
    러스트는 변수가 범위를 벗어나면 "drop"이란 함수를 호출함.
    drop함수는 String타입을 구현한 개발자가 메모리를 해제하는 코드를 작성해 둔 함수임. 닫는 중괄호를 만나면 자동으로 drop을 호출함.
     */


}

