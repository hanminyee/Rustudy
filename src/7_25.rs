use std::io; //표준 라이브러리를 읽어오는 것, 표준 = std 그 중에서 io라이브러리를 가져오는 것

fn main() {
    println!("숫자를 밪혀봅시다!");

    println!("정답이라고 생각하는 숫자를 입력하세요.");

    let mut guess = String::new(); //변수를 생성할 수 있게 해줌
    /*
    "let"이라는 친구는 변수를 행성하게 해줌, 
    예를들면 let foo = bar; 이라는 코드는 새로운 변수 foo를 생성하고, bar라는 변수의 값을 "바인딩"함
    기본적으로 이렇게 선언하면 이 값을 바꿀 수 없음.
    
    근데?!
    let mut foo = bar; 라고 하면 값을 변경할 수 있음. 결국은 mut가 붙으면 가변, 안붙으면 불변이라는 것 같음

    위에서 보면 바인딩을 String::new() 로 해뒀는데, 이것은 새로운 string타입의 인스턴스를 생성하는 String::new 함수의 실행 결과를 바인딩 한 것임.
    ::new 의 :: 문법은 new함수가 String타입의 연관 함수라는 것을 의미함.
    이 때 연관함수란? 특정한 인스턴스가 아니라, 타입 자체에 구현된 함수임. 그니까 이건 정적 메서드 함수라고 생각하면 됨 (ㅅㅂ 먼소리노)

    new함수는 새로운 빈 문자열을 생성함.
    근데 String뿐만 아니라, 다양한 타입에서 new함수를 제공함. 왜냐면 특정 타입의 새로운 값을 생성하는 함수에 new라는 이름을 부여한거라서 그럼

    결론적으로 let mut guess = String::new(); 라는 구문은, 변경가능한 새로운 변수를 선언하고, 여기에 아무것도 들어있지 않은 String타입의 새로운 인스턴스를 연결하는 구문임
     */

    io::stdin().read_line(&mut guess)
        .expect("입력한 값을 읽지 못했습니다.");
    /*
    여기에 보면 stdin()이 있는데, 이건 위에 std::in을 use 해줘서 가능한거임. 만약에 위에 이거 안해줬으면 std::io::stdin 이렇게 작성해도 무관하긴 한데 존나 복잡해보임 ㅇㅈ?
    stdin <-- 이새끼가 사용자의 입력을 받아옴;; 그거하난 확실히 하는 새끼;;

    read_line()이라는 메소드가 있음. 근데 이 친구의 역할은 사용자가 입력한 값을 표준 입력으로부터 읽어서 문자열에 저장하는거임.
    근데 잘 생각해보면 만약에 변수 선언할 때 실수로 mut안써서 불변하게 해놓으면 사용자가 입력한 값을 넣을 수가 없어서 졷버그가 터짐 그니까 잘 보고 써야함.(꼭 가변한걸로)

    위에 read_line에 파라미터로 들어산 & <-- 얘는 레퍼런스 타입이라는 것을 지시함. 그냥 포인터 비슷한거 생각하면 됨. 근데 다름. 나중에 설명해준다고 하시네요~
    하여튼 기본적으로 포인터랑 다른점은 러스트에서 & <-- 이새끼는 참조해도 그 값을 변경시킬 수 없음.(기본적으로는)
    근데 우리는 변경가능한 참조를 전달하기 위해서 &guess가 아니라 &mut guess 로 표기해서 전달함

    *********존나 중요한 것*********
    둘째줄에 잘 보면 .expect가 있음. 벌써부터 자바의 악몽이 떠오르지만 알아보자면
    우리가 read_line의 메소드는 사용자가 입력한 값을 우리가 전달한 문자열 변수에 대입하지만, io::Result 타입의 값을 리턴하기도 함.
    러스트 언어 자체가 표준 라이브러리 안에 범용의 Result타입을 비롯해서 io::Result와 같이 서브 모듈 전용의 Result타입 등 여러개의 Result타입을 정의하고 있음.

    근데? Result타입이 뭔데 씹덕아;;
    얘는 그냥 열거자임. 즉, enums임. 미리 정의된 범위의 값을 가지는 타입이고, 이 값들은 열거자의 열것값이라고 부름. 자세한 내용은~ 6장에서 한다고 하시네요~
    Result열거자의 경우 Ok, Err 두개의 값이 있음. Ok는 작업이 성공적으로 완료된 것을 의미함. Ok 열것값은 성공적으로 생성된 값을 보관함.
    근데 Err친구는 작업이 실패한걸 의미함. 그리고 Err 열것값은 작업이 실패한 원인에 대한 정보를 보관함.
    얘 목적은 에러처리를 위한 정보를 인코딩하기 위한 것임. 다른타입이랑 똑같이 Result타입도 각자 자신에게 정의된 메소드를 포함하고있음.
    io::Result타입의 인스턴스는 위에 썼던 expect 메소드를 정의하고있음.
    만약에 io::Result타입의 인스턴스가 Err값이라면, expect 메소드는 프로그램 실행을 종료하고 "님아 ㅈ버그뜸;;" 하면서 우리한테 이야기해줌
    근데 Ok면 그냥 가는거야.그냥 리턴해서 바로 진행시켜 해버림
    만약에 expect메소드를 안해주면 돌아는 가는데 경고뜸 --> "니가 러스트 쓰는 새끼라면 이정돈 해주겠지;; 보안때문에 하는건데;;" 라는 뜻
     */

    println!("입력한 값: {}", guess); //값 출력
    /*
    얘도 중요함
    자리지정자 라는 건데, 위에 사용된 중괄호가 "자리지정자"라고 불림.
    얘는 어디 출력할지 자리 잡아놓는 애라고 생각하면 됨.
    예로서 println!("x = {}, y = {}", x, y); 하면 첫째 자리에 x, 둘째 자리에 y가 들어감
     */

}
