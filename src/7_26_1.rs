/*
이번엔 난수생성을 해볼거임
근데 러스트는 난수생성 기능 기본으로 제공을 안함
그래서 우리는 crate 라는 것을 사용해 볼 것임
얘는 그냥 소스파일의 집합임.
외부 크레이트를 사용할 때는 Cargo.toml이라는 파일에 있는 dependency 영역에 내가 원하는 크레이트를 추가해주면 됨.
따라서 우리는 우리의 Cargo.toml영역에 추가할거임 뭐를? rand = "0.6.1" 을
바꾼 다음에 cargo build 해보면 마구마구 다운받음 뭔가를 그게 소스파일임

카고가 가지고있는 장점이 하나 더 있는데, 바로 Cargo.lock 파일임
얘는 [다른 누군가가 이 코드를 빌드하더라도 매번 같은 결과물을 재생산하기 위한 역할]임.
카고는 무조건 명시된 버전의 의존 패키지만을 사용함.
예를들어 만약에 다음주에 러스트 팀이 rand패키지의 버그를 수정했는데 그 버전이 우리 코드에서 컴파일 안되면? 졷됨;;
그래서 우리가 Cargo.lock을 사용하는거임.
이 파일은 처음으로 cargo build 했을 때 생성되면서, 처음 빌드할 때 조건에 맞는 모든 의존 패키지를 검색해 Cargo.lock 파일에 기록함.
그 다음부터는 프로젝트를 빌드할 때 마다 카도는 Cargo.lock 파일이 존재하는지 확인하고 필요한 버전을 다시 확인하는게 아니라 [이 Cargo.lock 파일에 기록된 버전을 사용함]
즉, 그때마다 보는게 아니라 Cargo.lock이 버전의 기준이 되는거임.

그리고 카고는 update라는 명령으로 크레이트를 업데이트 할 수 있게 지원함.
이 명령을 쓰면 Cargo.lock 개무시하고 Cargo.toml파일에 지정된 조건에 해당하는 가장 최신 버전을 다시 찾아버림. 
얘가 확인해서 ㅈ버그 없다고 판단되면 Cargo.lock 파일의 버전을 갱신함.

근데 우리가 0.6.1 로 쓰고있기 때문에 우리는 무조건 0.7.0보다 낮은 버전의 크레이트만 검색함.
그래서 0.7.0이상 버전 쓰고싶으면 우리가 Cargo.toml파일을 rand = "0.7.0"으로 수정하면 가능하긴 함
*/


use std::io; 
use rand::Rng; //얘는 난수생성기 rand에 구현된 메소드를 정의함. Rng는 트레이트라는 건데 이건 10장에서 설명해준다고 하네요~

fn main() {
    println!("숫자를 밪혀봅시다!");

    let secret_number = rand::thread_rng().gen_range(1, 101);
    /*
    얘는 뭐냐?
    우선, rand::thread_rng 함수는 우리가 사용할 난수생성기를 리턴함.
    얘가 리턴하는 생성기는 현재 코드를 실행 중인 스레드 안에 존재하고, 운영체제가 지정한 시드값을 사용함.(난수인듯 난수아닌새끼;;)
    그런 다음, 생성기의 gen_range메소드를 호출함. 이 메소드는 use rand::Rng구문을 이용해서 코드의 실행 범위로 불러온 Rng트레이트에 정의되어있음
    그리고 gen_range메소드는 인수로 지정된 두 값 사이의 난수를 선택해 리턴함. 그니까 우리는 1, 101 넣었으니까 1~100사이임. ok? 마지막은 포함안되는거 국룰시치;;
     */

    println!("사용자가 맞혀야 할 숫자: {}", secret_number);
    /*
    아까 만들었던 난수를 출력해주는 거임.
     */

    println!("정답이라고 생각하는 숫자를 입력하세요.");

    let mut guess = String::new(); 

    io::stdin().read_line(&mut guess)
        .expect("입력한 값을 읽지 못했습니다.");

    println!("입력한 값: {}", guess); 
}
