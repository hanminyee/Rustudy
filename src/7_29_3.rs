//복제, 복사하는법
fn main(){
    let s1 = String::from("hello");
    let s2 = s1.clone();
    /*
    clone 메소드를 쓰면 정상적으로 동작함. 힙데이터가 복사되는 것과 정확히 같은 동작을 하는데, 하나의 포인터가 아닌 각각 개별의 메모리를 가리키는 포인터를 가지게 됨.
     */


    let x = 5;
    let y = x;
    let k = y.clone();
    println!("x = {}  y = {}  k = {}", x,y,k);
    /*
    정수형 데이터는 이러한 방식으로 복사가 가능하다. 왜일까..?

    그 이유는 정수형 같은 타입은 컴파일 시점에 이미 그 크기를 알 수 있으며, 온전히 스택에 저장되기 때문에 실제 값을 복사해도 괜찮다.
    심지어 여기다가 clone 메소드 사용해도 문제가 없음
     */



    /*
    러스트는 스택에 저장되는 정수형 같은 타입에 적용할 수 있는 Copy 트레이트 라는 특별한 특성을 제공한다.
    만일 어떤 타입에 Copy 트레이트가 적용되어 있다면 이전 변수를 새 변수에 할당해도 무효화 되지않음.
    다만, 어떤 타입, 혹은 그 타입의 어느 일부에 Drop 트레이트가 적용되어 있다면, Copy 트레이트를 적용할 수 없음.
    만약에 하려고하면 에러남.
    사용자 정의 타입에 Copy 트레이트를 적용하는 방법은 부록 C를 참고하세요~

    그러면 어떤 타입들에 Copy 트레이트가 적용되어 있을까?
    스칼라 값들에는 전부 Copy 트레이트가 적용되어있다. 또한 할당이 필요하거나 특정 형태의 자원에도 Copy트레이트가 적용되어있다.
    몇개 나열하자면
    - i32, u32 와 같은 모든 정수형 타입
    - true / false 값만을 가지는 boolean타입(bool)
    - 문자타입 char
    - f64와 같은 모든 부동 소수점 타입
    - Copy 트레이트가 적용된 타입만을 포함하는 튜플(예를들면 (i32, i64)튜플에는 Copy 트레이트가 적용됨. 근데 (i32, String)에는 적용 안됨)
     */
}
