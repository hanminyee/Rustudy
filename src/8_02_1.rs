/*
이번엔 메소드에 대해서 알아보자.
메소드는 함수와 유사함. 함수와 마찬가지로 fn키워드를 이용해 정의해야하고, 이름과 매개변수 리턴타입 등을 정할 수 있음.
또한 함수와 마찬가지로 호출 시 실행할 일련의 코드를 정의하고있음.
그치만 함수와 다른 점은 구조체의 컨텍스트 안에 정의되어야하고, 첫 파라미터는 항상 메소드를 호출할 구조체의 인스턴스를 표현하는 "self"라는 키워드로 쓰여야함.
*/

/*
아래를 살펴보자. 우선 눈에 띄는건 #[derive(Debug)]  <- 얘인데
얘는 디버깅 정보를 출력하는 기능을 제공함. 그냥 디버깅할떄 편하려고 쓰는애

둘째로 눈에 띄는건 impl(implementation) 이라는 친구인데,
이 블록은 아까 말했던 "컨텍스트"와 관련이 있다.
Rectangle 타입의 컨텍스트 안에 함수를 정의하려면 impl 블록을 이용해야하고, 그 다음 area함수를 impl의 중괄호 안에 선언하고 첫번째 파라미터의 이름과 함수를 모두 &self로 바꾸면 됨.
이렇게 하면 area()메소드를 Rectangle 인스턴스 상에서 호출할 수 있음.
즉, 인스턴스 다음에 마침표, 메소드 이름, 괄호, 인수를 전달하면됨

그리고 area함수는 Rectangle 구조체의 컨텍스트 안에 존재하므로 러스트는 self의 타입이 Rectangle이라는 것을 알고있음.
그래서 메소드르는 self에 대한 소유권을 갖거나, self의 불변 인스턴스를 대여하거나, 다른 파라미터처럼 self의 가변 인스턴스를 대여하는 것도 가능.
그러나 아래의 코드는 단순히 구조체의 데이터만 읽을 뿐, 값을 쓰지는 않아서 소유권을 가질 필요가 ㅇ벗음. 그래서 그냥 &self를 파라미터로 사용한거임.
만약에 바꾸고싶거나 쓰고싶으면 &mut self 하면 됨.

근데 C랑은 다른 점이 있음.
객체의 메소드를 직접 호출할 때는 "."을 쓰고 포인터를 이용해 호출하면 "->"를 쓰는 C계열과 달리
러스트는 "자동참조"랑 "역참조"를 제공함.
그래서
p1.distance(&p2);
(&p1).distance(&p2);
이 두 코드는 완전히 동일함.
왜냐면 러스트 컴파일러는 이미 self의 타입을 명확하게 알고있기 때문임.
*/
#[derive(Debug)]
struct Rectangle{
    width: u32,
    height: u32,
}

impl Rectangle{
    fn area(&self) -> u32{
        self.width * self.height
    }
}

fn main(){
    let lect1 = Rectangle{
        width: 30,
        height: 50,
    }

    println!{
        "사각형의 면적: {} 제곱픽셀",
        rect1.area()
    };
}
